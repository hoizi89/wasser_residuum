# ESPHome Konfiguration für ADXL345 Vibrations-basierte Durchfluss-Erkennung
#
# Hardware:
#   - ESP8266 (D1 Mini) oder ESP32
#   - ADXL345 Beschleunigungssensor (~4€)
#
# Verkabelung (I2C):
#   ADXL345    ESP8266/ESP32
#   VCC    →   3.3V
#   GND    →   GND
#   SDA    →   D2 (GPIO4) / GPIO21
#   SCL    →   D1 (GPIO5) / GPIO22
#
# Montage: Sensor fest am Wasserrohr befestigen (Kabelbinder/Klebeband)

esphome:
  name: wasser-vibration
  friendly_name: Wasser Vibration

esp8266:
  board: d1_mini
  # Für ESP32 stattdessen:
  # esp32:
  #   board: esp32dev

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

api:
  encryption:
    key: !secret api_encryption_key

ota:
  platform: esphome
  password: !secret ota_password

logger:
  level: INFO

i2c:
  sda: GPIO4  # D2 auf D1 Mini
  scl: GPIO5  # D1 auf D1 Mini
  scan: true

sensor:
  # ADXL345 Rohdaten (optional, für Debugging)
  - platform: adxl345
    id: accel
    address: 0x53
    update_interval: 50ms  # 20 Hz Abtastrate

    accel_x:
      name: "Vibration X"
      id: accel_x
      internal: true

    accel_y:
      name: "Vibration Y"
      id: accel_y
      internal: true

    accel_z:
      name: "Vibration Z"
      id: accel_z
      internal: true

  # Vibrations-Intensität (kombiniert alle Achsen)
  - platform: template
    name: "Vibration Intensität"
    id: vibration_intensity
    unit_of_measurement: "m/s²"
    accuracy_decimals: 3
    update_interval: 100ms
    lambda: |-
      // Berechne Gesamtbeschleunigung minus Gravitation
      float x = id(accel_x).state;
      float y = id(accel_y).state;
      float z = id(accel_z).state;

      // Magnitude der Beschleunigung
      float magnitude = sqrt(x*x + y*y + z*z);

      // Subtrahiere Gravitation (~9.81 m/s²)
      float vibration = abs(magnitude - 9.81);

      return vibration;

  # Gleitender Durchschnitt für stabilere Werte
  - platform: template
    name: "Vibration Gefiltert"
    id: vibration_filtered
    unit_of_measurement: "m/s²"
    accuracy_decimals: 3
    update_interval: 500ms
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1
    lambda: |-
      return id(vibration_intensity).state;

  # Geschätzter Durchfluss basierend auf Vibration
  - platform: template
    name: "Geschätzter Durchfluss"
    id: estimated_flow
    unit_of_measurement: "L/min"
    accuracy_decimals: 1
    device_class: water
    update_interval: 1s
    lambda: |-
      float vib = id(vibration_filtered).state;

      // Schwellwert für "kein Durchfluss"
      if (vib < 0.05) {
        return 0.0;
      }

      // Lineare Schätzung: Vibration → Durchfluss
      // Diese Werte müssen kalibriert werden!
      // Typisch: 0.1 m/s² ≈ 3 L/min, 0.5 m/s² ≈ 15 L/min
      float flow = vib * 30.0;  // Kalibrierungsfaktor

      // Maximum begrenzen
      return min(flow, 25.0f);

binary_sensor:
  # Durchfluss erkannt (Ja/Nein)
  - platform: template
    name: "Wasser fließt"
    id: water_flowing
    device_class: running
    lambda: |-
      return id(vibration_filtered).state > 0.05;
    filters:
      - delayed_on: 500ms   # Muss 0.5s aktiv sein
      - delayed_off: 2s     # Bleibt 2s nach Ende aktiv

  # Starker Durchfluss (z.B. Dusche)
  - platform: template
    name: "Starker Durchfluss"
    id: high_flow
    lambda: |-
      return id(vibration_filtered).state > 0.3;

# Status LED
status_led:
  pin:
    number: GPIO2
    inverted: true

# Kalibrierungs-Helfer
button:
  - platform: template
    name: "Kalibrierung starten"
    on_press:
      - logger.log: "Starte Kalibrierung - 10 Sekunden kein Wasser laufen lassen!"
      # Hier könnte man die Baseline speichern
