# ESPHome ADXL345 - Varianz-basierte Wassererkennung
# Y-Achse zeigt besten Unterschied: AUS=0.041, EIN=0.052 (+26%)
# Schwellwert: 0.048 m/s² (etwas hoeher gegen Fehlalarme)
#
# Flow-Kalibrierung (kalibriert: 1L in 12s bei Std 0.050):
#   - Threshold 0.048: darunter = 0 L/min
#   - Bei Std 0.050: ca. 5 L/min
#   - Bei Std 0.055: ca. 17 L/min
#   - Bei Std 0.060: ca. 30 L/min (Faktor 2500)
esphome:
  name: wasser-vibration
  friendly_name: Wasser Vibration
  on_boot:
    priority: 200
    then:
      - delay: 100ms
      - lambda: |-
          uint8_t cmd[2];
          cmd[0] = 0x2D; cmd[1] = 0x08;
          id(i2c_bus).write(0x53, cmd, 2);
          cmd[0] = 0x31; cmd[1] = 0x08;
          id(i2c_bus).write(0x53, cmd, 2);
          cmd[0] = 0x2C; cmd[1] = 0x0C;
          id(i2c_bus).write(0x53, cmd, 2);
          ESP_LOGI("adxl", "ADXL345 init OK");

esp32:
  board: esp32dev
  framework:
    type: esp-idf

wifi:
  ssid: "A1-26B54F"
  password: "H5BJWWP8DC"

api:
  encryption:
    key: "UQIu+mEViveuNoyWdbsEmAvNa/DNBw85HF/TgWTUF2Y="

ota:
  platform: esphome
  password: "21d4912acd914b371b737862c74c6049"

logger:
  level: WARN

i2c:
  id: i2c_bus
  sda: GPIO21
  scl: GPIO22
  scan: true
  frequency: 400kHz

globals:
  - id: sample_count
    type: int
    initial_value: '0'
  # Y-Achse (beste Empfindlichkeit)
  - id: sum_y
    type: float
    initial_value: '0.0'
  - id: sum_y_sq
    type: float
    initial_value: '0.0'
  - id: std_y
    type: float
    initial_value: '0.041'
  # Datensammlung
  - id: collecting_data
    type: bool
    initial_value: 'false'
  - id: collect_count
    type: int
    initial_value: '0'

interval:
  - interval: 5ms
    then:
      - lambda: |-
          uint8_t reg = 0x32;
          uint8_t data[6];
          if (id(i2c_bus).write(0x53, &reg, 1, false) != i2c::ERROR_OK) return;
          if (id(i2c_bus).read(0x53, data, 6) != i2c::ERROR_OK) return;

          int16_t x = data[0] | (data[1] << 8);
          int16_t y = data[2] | (data[3] << 8);
          int16_t z = data[4] | (data[5] << 8);

          float ax = x * 0.0039f * 9.81f;
          float ay = y * 0.0039f * 9.81f;
          float az = z * 0.0039f * 9.81f;

          if (id(collecting_data)) {
            float mag = sqrt(ax*ax + ay*ay + az*az);
            ESP_LOGW("DATA", "%.4f,%.4f,%.4f,%.4f", ax, ay, az, mag);
            id(collect_count)++;
          }

          // Nur Y-Achse akkumulieren
          id(sum_y) += ay;
          id(sum_y_sq) += ay * ay;
          id(sample_count)++;

  - interval: 500ms
    then:
      - lambda: |-
          if (id(sample_count) < 50) return;

          float n = id(sample_count);
          float mean_y = id(sum_y) / n;
          float var_y = (id(sum_y_sq) / n) - (mean_y * mean_y);
          float std = sqrt(var_y);

          // Glättung
          id(std_y) = id(std_y) * 0.7f + std * 0.3f;

          id(sample_count) = 0;
          id(sum_y) = 0.0f;
          id(sum_y_sq) = 0.0f;

sensor:
  - platform: template
    name: "Vibration Y-Std"
    id: vibration_std
    unit_of_measurement: "m/s²"
    accuracy_decimals: 4
    state_class: measurement
    icon: "mdi:chart-bell-curve"
    update_interval: 500ms
    lambda: return id(std_y);

  - platform: template
    name: "Durchfluss"
    id: durchfluss
    unit_of_measurement: "L/min"
    accuracy_decimals: 1
    device_class: water
    state_class: measurement
    update_interval: 1s
    lambda: |-
      // Kalibriert: 1L in 12s bei Std 0.050 = 5 L/min
      // Faktor = 5 / (0.050 - 0.048) = 2500
      float std = id(std_y);
      if (std < 0.048f) return 0.0f;
      float flow = (std - 0.048f) * 2500.0f;
      return fmin(flow, 30.0f);

binary_sensor:
  - platform: template
    name: "Wasser Fliesst"
    id: wasser_fliesst
    device_class: running
    lambda: return id(std_y) > 0.048f;
    filters:
      - delayed_on: 2s
      - delayed_off: 5s

text_sensor:
  - platform: template
    name: "Status"
    update_interval: 1s
    lambda: |-
      float std = id(std_y);
      char buf[64];
      // Kalibriert mit Faktor 2500 (1L/12s bei 0.050)
      if (std < 0.048f) {
        snprintf(buf, sizeof(buf), "Kein Wasser (%.4f)", std);
      } else if (std < 0.050f) {
        snprintf(buf, sizeof(buf), "Schwach <5L/min (%.4f)", std);
      } else if (std < 0.054f) {
        snprintf(buf, sizeof(buf), "Mittel 5-15L/min (%.4f)", std);
      } else if (std < 0.060f) {
        snprintf(buf, sizeof(buf), "Stark 15-30L/min (%.4f)", std);
      } else {
        snprintf(buf, sizeof(buf), "Sehr stark 30+L/min (%.4f)", std);
      }
      return {buf};

button:
  - platform: template
    name: "Daten Sammeln (10s)"
    icon: "mdi:database-export"
    on_press:
      - lambda: |-
          id(collecting_data) = true;
          id(collect_count) = 0;
          ESP_LOGW("DATA", "===== START =====");
          ESP_LOGW("DATA", "X,Y,Z,Mag");
      - delay: 10s
      - lambda: |-
          id(collecting_data) = false;
          ESP_LOGW("DATA", "===== ENDE (%d) =====", id(collect_count));
